module Monociclo (
	input						clk_i,
	input						rst_ni,
	output		[63:0]	wb_data_o
	);

/*
	IF: 		Búsqueda de instrucciones
	ID/RF: 	Decodificación de instrucciones y búsqueda de operandos
	EX/AG: 	Ejecución/Cálculo de la dirección de memoria
	MEM: 		Búsqueda de los operandos en memoria
	WB: 		Almacenamiento/Escritura de retorno del resultado
*/	

///////////////////////// DEFINICIÓN DE SEÑALES /////////////////////////
	
// FETCH
	reg			[31:0]	pc;
	wire			[31:0]	pc_next;
	wire			[31:0]	if_instr_o;

// DECODE / REGISTER FILE READ
	wire						id_memtoreg_o;
	wire						id_memread_o;
	wire						id_regwrite_o;
   wire						id_memwrite_o;
	wire						id_alusrc_o;

// REGISTER READ / 
	wire			[63:0]	rr_dataa_o;
	wire			[63:0]	rr_datab_o;

// SIGN EXTEND
	wire			[64:0]	se_inmed_o;
	wire			[64:0]	se_muxalusrc_w;

// EXECUTION
	wire			[63:0]	ex_resultado_o;

// MEMORY ACCESS
	wire			[63:0]	mem_data_o;

/////////////////////////	ETAPA FETCH - BÚSQUEDA DE INSTRUCCIONES /////////////////////////
	
	always @(posedge clk_i, negedge rst_ni)
	begin
		if (!rst_ni)
			pc <= 32'b0;			//Si reset, reiniciar el contador de programa (PC) 
		else
			pc <= pc_next;			//De lo contrario, aumentar el valor de contador de programa (PC) 
	end
// Calculo del PC
	fulladderN #( 
		.N				(32)
	)	
	sum4
	(
		.c_i			(1'b0),
		.a_i			(pc),
		.b_i			(32'h4),
		.s_o			(pc_next),
		.c_o			(c_o)
	);
// Instruction cache
	Memoria icache (
		.clk_i		(clk_i),
// Puerto de lectura
		.rden_i		(1'b1),		//Habilitación de lectura
		.addrd_i		(pc[6:2]),	//Dirección
		.datard_o	(if_instr_o),//Dato
// Puerto de escritura
		.wren_i		(1'b0),		//Habilitación de escritura
		.addwr_i		(32'b0),		//Dirección
		.datawr_i	(32'b0)		//Dato
	);

///////////////////////// ETAPA DECODE - DECODIFICACIÓN Y BUSQUEDA DE OPERANDOS /////////////////////////

	decode deco(
		.opcode_i	(if_instr_o[6:0]),
		.memtoreg_o	(id_memtoreg_o),
		.memread_o	(id_memread_o),
		.regwrite_o	(id_regwrite_o),
		.memwrite_o	(id_memwrite_o),
		.alusrc_o	(id_alusrc_o)
	);
	
	//////////////////////////
	//	REGISTER READ - BÚSQUEDA DE OPERANDOS
	//////////////////////////
	registerfile #(
		.WIDTH 		(64),		//ancho
		.DEPTH 		(5)		//profundidad
	)
	regfile
	(
	//Señales generales
		.clk_i		(clk_i),
	//1er Puerto de lectura - Puerto A
		.rdena_i		(1'b1),					//Habilitación de lectura
		.addrda_i	(if_instr_o[19:15]),	//Dirección
		.datarda_o	(rr_dataa_o),			//Dato
	//2do Puerto de lectura - Puerto B
		.rdenb_i		(1'b1),					//Habilitación de lectura
		.addrdb_i	(if_instr_o[24:20]),	//Dirección
		.datardb_o	(rr_datab_o),			//Dato
	//Puerto de escritura
		.wren_i		(id_regwrite_o),		//Habilitación de escritura
		.addwr_i		(if_instr_o[11:7]),	//Dirección
		.datawr_i	(wb_data_o)				//Dato
	);

///////////////////////// EXTENCION DE SIGNO /////////////////////////
	
	signextend signext(
		.if_inst_i	(if_instr_o),
		.se_inmed_o	(se_inmed_o)
	);
	
		assign		se_muxalusrc_w	=	(id_alusrc_o)?se_inmed_o : rr_datab_o;

/////////////////////////	EXECUTION STAGE - EJECUCIÓN /////////////////////////
	
	alu execution (
	//operadores - fuentes
		.opea_i			(rr_dataa_o),
		.opeb_i			(se_muxalusrc_w),
	//codigo de la operación
		.operacion_i	({if_instr_o[30],if_instr_o[14:12]}),
	//resultado - destino
		.resultado_o	(ex_resultado_o)
	);

///////////////////////// DATA CACHE - ACCESO A MEMORIA /////////////////////////

	//Data cache
	Memoria #(
		.WIDTH		(64),
		.DEPTH		(8)
	)
	
	dcache
	(
		.clk_i		(clk_i),
	//Puerto de lectura
		.rden_i		(id_memread_o),			//Habilitación de lectura
		.addrd_i		(ex_resultado_o[10:3]),	//Dirección
		.datard_o	(mem_data_o),				//Dato
	//Puerto de escritura
		.wren_i		(id_memwrite_o),			//Habilitación de escritura
		.addwr_i		(ex_resultado_o[10:3]),	//Dirección
		.datawr_i	(rr_datab_o)				//Dato
	);

/////////////////////////	ETAPA WRITE BACK - ESCRITURA DE RETORN DEL RESULTADO /////////////////////////

	assign wb_data_o = (id_memtoreg_o) ? mem_data_o : ex_resultado_o;
		
endmodule 