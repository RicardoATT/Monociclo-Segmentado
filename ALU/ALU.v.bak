module	ALU #(
	parameter	WIDTH	= 64
)
(
	//operadores - fuentes
	input			[WIDTH-1:0]	opea_i,
	input			[WIDTH-1:0]	opeb_i,
	//codigo de la operaci√≥n
	input			[3:0]		operacion_i,
	//resultado - destino
	output reg	[WIDTH-1:0]	resultado_o
	
);

	reg						carry_i;
	reg			[WIDTH-1:0]	opeb_r;
	wire			[WIDTH-1:0]	res_sumres_w;
	always @(*)
	begin
		case (operacion_i)
			4'b0_000:						//Suma
					begin
						carry_i		=	1'b0;
						opeb_r 		=	opeb_i;
						resultado_o	=	res_sumres_w;
					end
			4'b1_000:						//Resta
					begin
						carry_i		=	1'b1;
						opeb_r		=	~opeb_i;
						resultado_o	=	res_sumres_w;
					end
			4'b0_001:						//Shift Left Logical - sll
						resultado_o = opea_i << opeb_i;
			4'b0_010:						//Set if less than - slt
						if ($signed(opea_i) < $signed(opeb_i))
							resultado_o = 1;
						else
							resultado_o = 0;
			4'b0_011:						//Set if less than unsigned - sltu
						if (opea_i < opeb_i)
							resultado_o = 1;
						else
							resultado_o = 0;
			4'b0_100:						//xor
						resultado_o = opea_i ^ opeb_i;
			4'b0_101:						//shift right logical - srl
						resultado_o = opea_i >> opeb_i;
			4'b1_101:						//shift right arithmetic - sra
						resultado_o = opea_i >>> opeb_i;
			4'b0_110:						//or
						resultado_o = opea_i | opeb_i;
			4'b0_111:						//and
						resultado_o = opea_i & opeb_i;
			default:
						resultado_o = 32'b0;
		endcase
	end
	
	fulladderN sumres (
		.a_i				(opea_i),
		.b_i				(opeb_r),
		.c_i				(carry_i),
		.s_o				(res_sumres_w),
		.c_o				(carry_o)
	);
	
endmodule 